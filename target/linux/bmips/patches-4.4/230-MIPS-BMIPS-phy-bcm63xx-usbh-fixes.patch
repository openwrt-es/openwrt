--- a/drivers/phy/phy-bcm63xx-usbh.c
+++ b/drivers/phy/phy-bcm63xx-usbh.c
@@ -82,10 +82,18 @@ struct bcm63xx_usbh_phy_variant {
 	/* Test Port Control value to set if non-zero */
 	u32 tpc_val;
 
+	/* Setup bits to set/clear for power on */
+	u32 setup_set;
+	u32 setup_clr;
+
 	/* PLLC bits to set/clear for power on */
 	u32 power_pllc_set;
 	u32 power_pllc_clr;
 
+	/* USB clocks */
+	bool has_usb_clk;
+	bool has_usb_ref_clk;
+
 	/* Registers */
 	long regs[__USBH_ENUM_SIZE];
 };
@@ -116,14 +124,18 @@ static const struct bcm63xx_usbh_phy_var
 		[USBH_MDIO32]			= 0x18,
 		[USBH_USB_SIM_CONTROL]		= 0x20,
 	},
+	.setup_set = USBH_S_IOC,
+	.setup_clr = 0,
 	.usc_set = USBH_USC_LADDR_SEL,
 	.tpc_val = 0,
 	.power_pllc_set = USBH_6318_PLLC_PLL_SUSPEND_EN,
 	.power_pllc_clr = USBH_6318_PLLC_PLL_IDDQ_PWRDN,
+	.has_usb_clk = 1,
+	.has_usb_ref_clk = 1,
 };
 
-/* BCM6328, BCM63168, BCM63268, BCM6828, BCM68220 */
-static const struct bcm63xx_usbh_phy_variant usbh_bcm6328 __initconst = {
+/* BCM63268 */
+static const struct bcm63xx_usbh_phy_variant usbh_bcm63268 __initconst = {
 	.regs = {
 		[USBH_BRT_CONTROL1]		= 0x00,
 		[USBH_BRT_CONTROL2]		= 0x04,
@@ -140,10 +152,42 @@ static const struct bcm63xx_usbh_phy_var
 		[USBH_MDIO32]			= 0x30,
 		[USBH_USB_SIM_CONTROL]		= 0x34,
 	},
+	.setup_set = USBH_S_IOC,
+	.setup_clr = USBH_S_IPP,
 	.usc_set = 0,
 	.tpc_val = 0,
 	.power_pllc_set = 0,
 	.power_pllc_clr = USBH_PLLC_PLL_IDDQ_PWRDN | USBH_PLLC_PLL_PWRDN_DELAY,
+	.has_usb_clk = 1,
+	.has_usb_ref_clk = 1,
+};
+
+/* BCM6328 */
+static const struct bcm63xx_usbh_phy_variant usbh_bcm6328 __initconst = {
+	.regs = {
+		[USBH_BRT_CONTROL1]		= 0x00,
+		[USBH_BRT_CONTROL2]		= 0x04,
+		[USBH_BRT_STATUS1]		= 0x08,
+		[USBH_BRT_STATUS2]		= 0x0c,
+		[USBH_UTMI_CONTROL1]		= 0x10,
+		[USBH_TEST_PORT_CONTROL]	= 0x14,
+		[USBH_PLL_CONTROL1]		= 0x18,
+		[USBH_SWAP_CONTROL]		= 0x1c,
+		[USBH_GENERIC_CONTROL]		= 0x20,
+		[USBH_FRAME_ADJUST_VALUE]	= 0x24,
+		[USBH_SETUP]			= 0x28,
+		[USBH_MDIO]			= 0x2c,
+		[USBH_MDIO32]			= 0x30,
+		[USBH_USB_SIM_CONTROL]		= 0x34,
+	},
+	.setup_set = USBH_S_IOC,
+	.setup_clr = 0,
+	.usc_set = 0,
+	.tpc_val = 0,
+	.power_pllc_set = 0,
+	.power_pllc_clr = 0,
+	.has_usb_clk = 1,
+	.has_usb_ref_clk = 0,
 };
 
 /* BCM6358 */
@@ -170,6 +214,8 @@ static const struct bcm63xx_usbh_phy_var
 	 * help, so the magic value is used as-is.
 	 */
 	.tpc_val = 0x1c0020,
+	.has_usb_clk = 0,
+	.has_usb_ref_clk = 0,
 };
 
 /* BCM6368, BCM6362, BCM6816 */
@@ -190,10 +236,14 @@ static const struct bcm63xx_usbh_phy_var
 		[USBH_MDIO32]			= 0x30,
 		[USBH_USB_SIM_CONTROL]		= 0x34,
 	},
+	.setup_set = USBH_S_IOC,
+	.setup_clr = 0,
 	.usc_set = 0,
 	.tpc_val = 0,
 	.power_pllc_set = 0,
 	.power_pllc_clr = USBH_PLLC_PLL_IDDQ_PWRDN | USBH_PLLC_PLL_PWRDN_DELAY,
+	.has_usb_clk = 1,
+	.has_usb_ref_clk = 0,
 };
 
 static inline __pure bool usbh_has_reg(struct bcm63xx_usbh_phy *usbh,
@@ -253,8 +303,8 @@ static int bcm63xx_usbh_phy_init(struct
 	if (usbh_has_reg(usbh, USBH_SETUP)) {
 		u32 val = usbh_readl(usbh, USBH_SETUP);
 
-		val |= USBH_S_IOC;
-		val &= ~USBH_S_IPP;
+		val |= usbh->variant.setup_set;
+		val &= ~usbh->variant.setup_clr;
 
 		usbh_writel(usbh, USBH_SETUP, val);
 	}
@@ -364,20 +414,28 @@ static int __init bcm63xx_usbh_phy_probe
 		return ret;
 	}
 
-	usbh->usbh_clk = devm_clk_get(dev, "usbh");
-	if (IS_ERR(usbh->usbh_clk)) {
-		ret = PTR_ERR(usbh->usbh_clk);
-		if (ret != -EPROBE_DEFER)
-			dev_err(dev, "failed to get usbh clock: %d\n", ret);
-		return ret;
-	}
-
-	usbh->usb_ref_clk = devm_clk_get(dev, "usb_ref");
-	if (IS_ERR(usbh->usb_ref_clk)) {
-		ret = PTR_ERR(usbh->usb_ref_clk);
-		if (ret != -EPROBE_DEFER)
-			dev_err(dev, "failed to get usb_ref clock: %d\n", ret);
-		return ret;
+	if (variant->has_usb_clk) {
+		usbh->usbh_clk = devm_clk_get(dev, "usbh");
+		if (IS_ERR(usbh->usbh_clk)) {
+			ret = PTR_ERR(usbh->usbh_clk);
+			if (ret != -EPROBE_DEFER)
+				dev_err(dev, "failed to get usbh clock: %d\n", ret);
+			return ret;
+		}
+	} else {
+		usbh->usbh_clk = NULL;
+	}
+
+	if (variant->has_usb_ref_clk) {
+		usbh->usb_ref_clk = devm_clk_get(dev, "usb_ref");
+		if (IS_ERR(usbh->usb_ref_clk)) {
+			ret = PTR_ERR(usbh->usb_ref_clk);
+			if (ret != -EPROBE_DEFER)
+				dev_err(dev, "failed to get usb_ref clock: %d\n", ret);
+			return ret;
+		}
+	} else {
+		usbh->usb_ref_clk = NULL;
 	}
 
 	phy = devm_phy_create(dev, NULL, &bcm63xx_usbh_phy_ops);
@@ -403,6 +461,7 @@ static int __init bcm63xx_usbh_phy_probe
 
 static const struct of_device_id bcm63xx_usbh_phy_ids[] __initconst = {
 	{ .compatible = "brcm,bcm6318-usbh", .data = &usbh_bcm6318 },
+	{ .compatible = "brcm,bcm63268-usbh", .data = &usbh_bcm63268 },
 	{ .compatible = "brcm,bcm6328-usbh", .data = &usbh_bcm6328 },
 	{ .compatible = "brcm,bcm6358-usbh", .data = &usbh_bcm6358 },
 	{ .compatible = "brcm,bcm6368-usbh", .data = &usbh_bcm6368 },
